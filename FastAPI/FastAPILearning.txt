Fast API is a modern python web framework very efficient in building API
developed by sebastun ramirez in dec 2018
As it works on the functionality of starlette and pydantic libraries
in addition to high performance, FastAPI offers significant speed for development.
easy to learn and is completely production - ready

Getting Started 
    the first step in creating a FastAPI app is to declare the application object of FastAPI class.
                from fastapi import FastAPI
                app = FastAPI()
    
    the app object is the main point of interaction of the application with the client browser.
    the uvicorn server uses this object to listen to client request.

Create path operation :
    path is the URL which when visited by client invokes visits a mapped URL to one of the HTTP methods, an associated function is to be executed.
    we need to bind a view function to a URL and the corresponding HTTP method.

FastAPI uses swagger UI to produce this documentation.
we can see the Curl command internally executed, the request URL the response headers and Json format of servers response.

FastAPI generates a schema using OpenAPI specifications. 
this determine hoe to define API path, path parameters etc.

FastAPI supports another automatic documentation method provided by Redoc.

FastAPI doesnt contain any built in development server. Hence we need Uvicorn. 
It implements ASGI standards and lightning fast.
ASGI-Asynchronous server gateway interface
python web framworks implementing ASGI specifications provide high speed performance


Command and description 

--host TEXT : Bind socket to this host.
--port INTEGER : bind socket to this port 
--uds TEXT : bind to a UNIX domain socket
--fd INTEGER: bind to socket from this file descriptor 
--reload : enable auto-reload
--reload-dir PATH : set reload directories explicitly default current working directory 
--reload-include TEXT: includes files while watching. Includes '*.py' by default.
-reload-exclude TEXT : exclude while watching for files.
--reload-deploy FLOAT : delay between previous and next check default 0.25
-loop [auto|asyncio|uvloop] : event loop implementation.
--http [auto|h11|httptools]: HTTP protocol implementation
--interface auto|asgi|asgi|wsgi: select application interface.
--env-file PATH : Environment configuration file 
--log-config PATH: logging configuration file. Supported formats .ini, .json, .yaml.
--version : display the uvicorn version and exist.
--app-dir TEXT: look for app in the specified directory default current directory 
--help : show this message and exit.

Type Hints

    FastAPI makes extensive use of Type hinting feature made available in python version on 3.5 onwards
    pythons new type hinting features helps in prompting the user with the expectied type of parameters to be passed.
    this is done by adding colon and datatype after the parameter.

REST Architecture: 
    Relational State Transfer(REST): 
            it is software architectural style.
            it is a resource based Architecture where everything that REST server host is a resource having many representations.
            it uses HTTP methods for the operation on resources.
            The POST, GET, PUT and DELETE methods perform respectively CREATE, READ, UPDATE, DELETE operations.

        
    REST advantages:
        Scalability
        Simplicity
        Modifiability
        Reliability
        Portability
        Visibility

Path parameters :
    modern web frameworks use endpoints as part of URL instead of file based URL
    it helps user to remember application URL more effectively. 
    A path is the part of URL trailing after the first /.
                http://localhost:8000/hello/learning
        
        here /hello/learning is the path 
    such path string is given as parameter to operation decorator 
    the operation refers to HTTP method used by browser to send the data.
    these operations include GET, PUT etc. the operation decorator is immediately followed by a function that is executed when the specified URL is visited.

            from fastapi import FastAPI
            app = FastAPI()
            @app.get("/")
            async def index():
                return {"message": "Hello world"}

    here "/" is the path get is the operation, @app.get("/") is the path operation decorator and index()
    function termed as path operation function.


the async keyword in func defination tells FastAPI that it is to be run asynchronously without blocking the current
thread of execution.

this decorated function returns a JSON response.
the url endpoint can have one or more variable parameters.
these can be accepted by using python string formatting notation.


Path parameter with types:
    python type hints for parameter of function to be decorated.
            @app.get("/hello/{name}/{age})
            async def hello(name: str, age:int):
                return{"name":name, "age":age}

Query parameter :
    A method of passing request data to server is to append a query string to URL. 
                http://localhost/cgi-bin/hello.py?name=Ravi&age=20
    the trailing part of the URL after(?) is query string it is a list of param = val pairs concatinated by & symbol.
            from fastapi import FastAPI
            app = FastAPI()
            @app.get("/hello")
            async def hello(name:str, age:int):
                return{"name":name, "age":age}

Parameter Validation:
    it is possible to apply validation conditions on path parameters and query parameters of the URL.
    for this we need to import path class.
    for default value param we need to specify min and max len for string param.
                
                form fastapi import FastAPI, Path
                app = FastAPI()
                @app.get("/hello/{name}")
                async def hello(name:str=Path(...,min_length=3, max_length=10)):
                    return {"name" : name}

    FastAPI correctly identifies percent as query parameter with validation conditions applied.
    while the client can send the path and query parameters to the API server using GET method,
    we need to apply POST method to send some binary data as a part of the HTTP request.
    this binary data may be in the form of an object of an object of any python class.


Pydantic: 
    it is a python library for data parsing and validation. it uses type hinting mechanism of the newer version of 
    python and validates the type during runtime.

    Pydantic defines BaseModel class. it acts as the baseclass for creating user defined models.

            from fastapi import FastAPI
            from pydantic import BaseModel
            class student(BaseModel):
                id:int
                name:str
                subje : List[str]=[]

    
    the attributes of student class are declared with typehints.
    Pydantic will automatically get the data types converted whenever possible.
    Pydantic Models can be used to map with ORM models like SQLAlchemy.

Request Body
    we can use pydantic model object as request body of client request.
                from fastapi import FastAPI
                from pydantic import BaseModel, Field
                from typing import List

                app = FastAPI()
                
                class student(BaseModel):
                    id:int
                    name:str = Field(None, title="name of student", max_length=10)
                    subjects:List[str]=[]

                    @app.post("/students/")
                    async def student_data(s1:student):
                        return s1

                here student_data() fun is decorated by @app.post with /students/ as url endpoint
                it receives an object od student class as body parameter from client request.
        
        Templates: 
            fastapi rendors a JSON response to client. for this it need HTML response and FastAPI 
            has HTMLResponse class defined in fastapi.responses module.
            we need to add response_class as an additional parameter to operation decorator with Html response obj as value.

            Rendering raw html response is difficult alternatively it is possible to render prebuilt HTML pages as templates.
            to do this we need template library.

            web template lib has template engine that merges a static web page having place holder variables.
            data from any source such as db is merged to dynamically generate and render web page.

            FastAPI supports jinja2Templates class defined in fastapi.templates module.

            {% %} - statements
            { { }} - Expressions to print to the template output
            {# #} - Comments which are not included in the template output
            # # # - Line statements.

Static Files:
    it is required to include in the template response some resources that remain unchanged even if there is a certain dynamic data.
    such resources are called static assets.
    media files javascript files to be used for executing some front end code or stylesheets for formatting HTML. are the examples of static files.

Accessing form data:
    html form data can be accessed in a FastAPI operation function.
            @app.post("/submit/")
            async def submit(nm : str = Form(...), pwd : str = Form(...)):
                return {"username" : nm}

Uploading files: 
    to send a file to the server you need to use HTML forms as multipart/form-data and use input type as the file to render a button
    which means clicked allows you to select a file from file system.

            from fastapi import FastAPI, File, UploadFile, Request
            import uvicorn
            import shutil
            from fastapi.responses import HTMLResponse
            from fastapi.templating import jinja2Templates
            app = FastAPI()
            templates = Jinja2Templates(dictionary='templates')

            @app.get("/upload/", response_class=HTMLResponse)
            async def upload(request: Request):
                return templates.TemplateResponse("uploadfile.html", {"request":request})

Cookie Parameter:
    A cookie is one of the HTTP headers. the web server sends a response to the client in addition to the data requested it also inserts one or more cookies.
    A cookie is very small amout of data that is stored in the clients machine. 

    the cookies are useful for recording information about clients browsing. 
    cookies are relaible method of retrieving stateful information in otherwise stateless communication by HTTP protocol.

    in FastAPI the cookie parameter is set on the response object with help of set_cookie() method.

Head Parameter : 
    in order to read values of HTTP header that is a part of client request import the header object from FastAPI library
    and declare a parameter of Header type in operation function defination.

    the name of the parameter should match with HTTP header converted in Camel_case

                from typing import optional 
                from fastapi import FastAPI, Header

                app = FastAPI()
                @app.get("/headers/")
                async def read_header(accept_language:Operional[str]=Header(None)):
                    return {"Accept-Language": accept_language}

Response Model: 
    an operation function returns A JSON response to the client.
    the response can be in the form of python primary types like (numbers, list, dict, str).
    it can also be a pydantic model
    for a function to return a model object the operation decorator should declare a response_model parameter.

    with the help of response model fastapi converts the output data to structure of model class.
    it validates the data, add a JSON schema for the response in the OpenAPI path operation.
    one of the imp adv of response_model parameter is that we can format the output by selecting the fields
    from the model to cast the response to an output model.

            from typing import List
            from fastapi import FastAPI 
            from pydantic import BaseModel, Field

            app = FastAPI()
            class student(BaseModel):
                id: int 
                name:str = Field(None, title="name of the student", max_length=10)
                marks: List[int] = []
                percent_marks : FLOAT
            class percent(BaseModel):
                id:int
                name:str = Field(None, title = "name of the student", max_length=10)
                percent_marks: FLOAT
            @app.post("/marks", response_model=percent)
            async def get_percent(s1:student):
                s1.percent_marks(s1.marks)/2
                return s1
        




